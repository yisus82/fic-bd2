$ sqlplus /
$ sqlplus [username[/password]] [@filename]

Comandos SQL*Plus: Uno por fila.
Sentencias SQL: Multifila y acaban en ;

DESC[RIBE] tabla


SELECT *
FROM emp
-- Obsérvese la incómoda visualización. Lo corregiremos a continuación.

Un ejemplo:

$ cat  login.sql
def_editor=vi
set pages 50
set feed 1
column empno  format  9990
column mgr    format  9990
column sal    format  99,990
column comm   format  99,990
column deptno format  90


SELECT empno, ename, sal, deptno
FROM   emp a
WHERE  sal = (SELECT MIN(sal)
              FROM   emp
              WHERE  deptno = a.deptno)
-- Después de introducir esta sentencia SQL usaremos en el 
-- ejercicio siguiente comandos SQL*Plus para modificarla, 
-- cambiar una línea, etc.



SQL*Plus usa un buffer para almacenar la última sentencia SQL ejecutada
(no afecta a los comandos SQL). Incorpora un editor de líneas elemental
para realizar cambios mínimos en esa sentencia SQL, como visualizarla
(LIST), posicionarse en una determinada línea (n), etc.

Además hay otros comandos SQL*Plus muy útiles
L[IST] [n [m]]            Visualiza líneas del buffer
A[PPEND] texto            Añade texto al final de la línea
C[HANGE] /viejo/nuevo/    Cambia una cadena de caracteres por otra
C[HANGE] /texto/          Una forma de "cambiarla"   
CL[EAR] BUFF[ER]          Elimina los datos del buffer
DEL    [n [m]]            Suprime líneas 
I[NPUT] [texto]           Añade una línea nueva despues de la "actual"
R[UN]                     Ejecuta lo almacenado en el buffer
/                         Ejecuta lo almacenado en el buffer
n                         Nos posiciona en una línea del buffer
n texto                   Introduce una línea con "texto" como contenido
                          antes de la línea "n".
0 texto                   Lo mismo, pero antes de la primera línea.
SAV[E] fichero[.sql]      Almacena el buffer en un fichero
GET fichero[.sql]         Pasa al buffer un fichero
STA[RT] fichero[.sql]     Ejecuta un fichero [.sql]
@fichero[.sql]            Idem
ED[IT] fichero[.sql]      Edita un fichero [.sql]
SPO[OL] [fichero[.lst]]   Define un fichero de registro de sesión
SPO[OL] {OFF/OUT}         Finaliza el registro de la sesión
HELP [tema]               Ayuda elemental sobre algunos temas
HO[ST] comando            Ejecuta un comando del sistema operativo


Revisa los anteriores para determinar las tres acciones a realizar

SELECT empno AS Codigo,
         ename || ' ' || 'trabaja de ' || ' ' || job  "Nombre y empleo"
FROM     emp

SELECT empno AS Codigo,
         ename || ' ' || 'trabaja de ' || ' ' || job  "Nombre y empleo"
FROM     emp
ORDER BY Codigo DESC;

SELECT empno AS Codigo,
         ename || ' ' || 'trabaja de ' || ' ' || job  "Nombre y empleo"
FROM     emp
ORDER BY 1 DESC;

SELECT empno AS Codigo,
         ename || ' ' || 'trabaja de ' || ' ' || job  "Nombre y empleo"
FROM     emp
ORDER BY deptno;
-- no habitual en otros SGBD


No hay datos sobre la pregunta f12 
SELECT empno, ename, sal, comm, sal + comm  
FROM   emp  -- comentario en una linea
/*  Vemos la aritmetica de 
los valores nulos  */
WHERE  sal > 1000 


SELECT empno, ename, sal, comm, sal + comm
FROM   emp
WHERE  sal > 1000
AND    comm IS NOT NULL
UNION
SELECT empno, ename, sal, comm, sal
FROM   emp
WHERE  sal > 1000
AND    comm IS NULL

-- Con la funcion Oracle  NVL
SELECT empno, ename, sal, comm, sal + NVL(comm,0)
FROM   emp  
WHERE  sal > 1000 

-- NVL: Función de Oracle. Asigna un valor dado (aquí 0)
-- al dato indicado (aquí comm), cuando éste es NULL.

desc  emp
desc dept

SELECT deptno
FROM   emp;

SELECT DISTINCT deptno
FROM   emp;    

SELECT empno, ename, mgr, a.deptno, dname, loc
FROM   emp a, dept

SELECT empno, ename, sal, a.deptno, loc
FROM   emp a, dept b
WHERE  a.deptno = b.deptno

SELECT empno, ename, sal, a.deptno, loc
FROM   emp a INNER JOIN  dept b
  ON   a.deptno = b.deptno

SELECT empno, ename, sal, a.deptno, loc
FROM   emp a       JOIN  dept b
  ON   a.deptno = b.deptno

SELECT empno, ename, sal, a.deptno, loc
FROM   emp a, dept b
WHERE  a.deptno = b.deptno
AND    SUBSTR(ename,1,1) = 'J'

SELECT empno, ename, sal, a.deptno, loc
FROM   emp a   JOIN  dept b
  ON   a.deptno = b.deptno
WHERE  SUBSTR(ename,1,1) = 'J'

SELECT empno, ename, sal, a.deptno, loc
FROM   emp a   JOIN  dept b
  ON   a.deptno = b.deptno
WHERE  INITCAP(ename) LIKE 'J%'

-- Funciones de interes:
-- INITCAP('MIs fIcherOs')  Mis Ficheros
-- UPPER('MIs fIcherOs')    MIS FICHEROS
-- LOWER('MIs fIcherOs')    mis ficheros
-- SUBSTR('Cadena',2,3)     ade         


SELECT   a.ename, a.job, a.sal, b.ename, b.job, b.sal
FROM     emp a, emp b
WHERE    a.sal > b.sal 
AND      b.ename = 'ALLEN'
-- ejemplo de non equijoin

SELECT   a.ename, a.job, a.sal, b.ename, b.job, b.sal
FROM     emp a  JOIN  emp b
  ON     a.sal > b.sal 
WHERE    b.ename = 'ALLEN'
SELECT e.empno, e.ename, m.empno cdg_mng, m.ename mng
FROM   emp e, emp m
WHERE  e.mgr = m.empno
-- Oracle suele denominar a esto un self join

SELECT e.empno, e.ename, m.empno cdg_mng, m.ename mng
FROM   emp e   JOIN  emp m
  ON   e.mgr = m.empno

SELECT empno, ename, d.deptno, d.dname
FROM   emp e, dept d
WHERE  e.deptno (+) = d.deptno
ORDER  by d.deptno
-- forma de realizar un outer join sobre Oracle
-- siempre despues de la tabla que necesita "mas" filas 
-- aqui seria la de empleados

-- otra forma de poner lo mismo
SELECT empno, ename, d.deptno, d.dname
FROM   dept d, emp e
WHERE  d.deptno = e.deptno (+)
ORDER  by d.deptno

SELECT empno, ename, d.deptno, d.dname
FROM   emp e  RIGHT OUTER JOIN dept d
  ON   e.deptno  = d.deptno
ORDER  by d.deptno

-- Si no conocemos los datos de las filas,
-- que sería lo habitual
SELECT empno, ename, d.deptno, d.dname
FROM   emp e  FULL  OUTER JOIN dept d
  ON   e.deptno  = d.deptno
ORDER  by d.deptno

SELECT empno, ename, d.deptno, d.dname
FROM   emp e  FULL        JOIN dept d
  ON   e.deptno  = d.deptno
ORDER  by d.deptno

SELECT   mgr, MAX(sal), MIN(sal)
FROM     emp
WHERE    mgr IS NOT NULL
GROUP BY mgr
HAVING   MIN(sal) > 1000

SELECT empno, ename, sal, deptno
FROM   emp a
WHERE  sal > (SELECT AVG(sal)
              FROM   emp)
-- subconsulta no sincronizada

SELECT empno, ename, sal, deptno
FROM   emp a
WHERE  sal = (SELECT MAX(sal)
              FROM   emp
              WHERE  deptno = a.deptno)
-- subconsulta sincronizada o correlacionada con el caso particular
-- de que la subconsulta recorre la misma tabla que la consulta principal

SELECT empno, ename, sal , comm
FROM   emp
WHERE  empno IN (SELECT mgr
                 FROM   emp)


SELECT empno, ename, sal, comm
FROM   emp
WHERE  empno NOT IN  (SELECT mgr
                      FROM   emp
                      WHERE  mgr IS NOT NULL)
-- por que es necesario el WHERE de la subconsulta?

                      
SELECT deptno, dname, loc
FROM   dept a
WHERE  NOT EXISTS (SELECT *
                   FROM   emp
                   WHERE  deptno = a.deptno)

Subconsulta con posibilidad de que no obtenga ninguna fila
entonces se usa un predicado de existencia y se permite
el SELECT * en la subconsulta.

Determina si podría usarse:

SELECT deptno, dname, loc
FROM   dept 
WHERE  deptno NOT IN (SELECT deptno
                      FROM   emp)

SELECT   empno, ename, job, sal, comm
FROM     emp
WHERE    sal > ANY (SELECT sal
                    FROM   emp
                    WHERE  job = 'SALESMAN')
ORDER BY sal

-- Es lo mismo usar ANY que SOME
--
-- otra posibilidad
SELECT   empno, ename, job, sal, comm
FROM     emp
WHERE    sal >   (SELECT MIN(sal)
                  FROM   emp
                  WHERE  job = 'SALESMAN')
ORDER BY sal


SELECT   empno, ename, job, sal, comm
FROM     emp
WHERE    sal > ALL (SELECT sal
                    FROM   emp
                    WHERE  job = 'SALESMAN')
ORDER BY sal

-- otra posibilidad
SELECT   empno, ename, job, sal, comm
FROM     emp
WHERE    sal >   (SELECT MAX(sal)
                  FROM   emp
                  WHERE  job = 'SALESMAN')
ORDER BY sal



SELECT a.deptno, a.dname , AVG(sal) Media
FROM   dept  a  JOIN  emp b
  ON   a.deptno = b.deptno
GROUP  BY a.deptno, a.dname
HAVING AVG(sal) = ( SELECT MAX(AVG(sal))
                    FROM   emp
                    GROUP BY deptno)



SELECT * 
FROM   USER_TABLES


SELECT * 
FROM   TAB

CREATE TABLE emp3
  AS SELECT *
     FROM   emp

SELECT * 
FROM   TAB;

DESC emp3

SELECT *
FROM   emp3;


INSERT INTO emp3
VALUES (7777,'GARCIA','ANALYST',7566,'12/01/81',1600,NULL,20);

INSERT INTO emp3
VALUES (8888,'GOMEZ','CLERK',7566,'12/01/81',950,NULL,20);


SELECT *
FROM emp3;



SELECT *
FROM   emp
WHERE  sal > 1600

SELECT *
FROM   emp
WHERE  sal > 1600
UNION 
SELECT *
FROM   emp
WHERE  sal > 1500
ORDER BY 1

-- El ORDER BY afecta a todo el conjunto


SELECT *
FROM   emp
WHERE  sal > 1600
UNION ALL
SELECT *
FROM   emp
WHERE  sal > 1500
ORDER BY 1


CREATE TABLE emp4
   (empno NUMBER(4) NOT NULL,
    ename VARCHAR2(15) ,
    job   VARCHAR2(10),
    sal   NUMBER(7,2) NOT NULL,
    comm  NUMBER(7,2));
    
DESC emp4

SELECT *
FROM   emp4;

SELECT * 
FROM   TAB



INSERT INTO tabla [ columna (, columna ...) ]
{ VALUES  ( valor [, valor ...]) / subconsulta }

INSERT INTO emp4
VALUES (7777,'GARCIA','ANALISTA',1600,300);

SELECT *
FROM   emp4;

-- Añadiendo valores a todos los atributos de la tabla

INSERT INTO emp4 (empno, ename, comm)
VALUES (7778,'GOMEZ',100);
?    

INSERT INTO emp4 (empno, ename, sal, comm)
VALUES (7778,'GOMEZ',1500,100);

INSERT INTO emp4 (empno, ename, sal, comm)
VALUES (7779,'GOMEZ',1000,NULL);

-- INSERT en este formato sólo permite una fila de cada vez

INSERT INTO emp4 (empno, ename, sal, comm)
VALUES (7780,'Gil',2000,90);

INSERT INTO emp4 
    SELECT empno, ename, job, sal, comm
    FROM   emp
    WHERE  deptno = 30;


INSERT INTO emp4 (empno, ename, sal)
    SELECT empno, ename, sal
    FROM   emp
    WHERE  deptno = 20;


UPDATE tabla
SET   columna = expresion [ , columna = expresion , ... ] 
[ WHERE condición ]

UPDATE emp4
  SET  sal = sal + 100;

-- Provoca una actualización de todas las filas    


UPDATE emp4
  SET  comm = 110
  WHERE comm IS NULL;


No hay datos sobre la pregunta f50 
DELETE FROM tabla
[ WHERE condición ]

DELETE FROM emp4
  WHERE sal > 2500;

-- Borrado de las filas que cumplen una condición.

No hay datos sobre la pregunta f52 
DELETE FROM emp4;

-- Borrado de todas las filas de la tabla !!.

SELECT * 
FROM   TAB;
    
DESC emp4

SELECT *
FROM   emp4;





SELECT * 
FROM   TAB

CREATE TABLE emp5 (
  empno   NUMBER(4),
  ename   VARCHAR2(10),
  mgr     NUMBER(4),
  deptno  NUMBER(2) );

SELECT *
FROM    emp5;

DROP TABLE emp5;

CREATE TABLE emp5
  (cdgem, nome, supervisor, cdgdp)
  AS  (SELECT  empno, ename, mgr, deptno 
       FROM    emp);

ALTER TABLE emp5
  ADD (posto VARCHAR2(9) ); 

-- En el estándar:
ALTER TABLE emp5
  ADD [COLUMN] (posto VARCHAR2(9) );

ALTER TABLE emp5
  ADD (sal NUMBER(7,2) DEFAULT 1500);
  
ALTER TABLE emp5
  MODIFY  (cdgdp VARCHAR2(2));

-- Pero necesita que no haya valores en esa columna ...

UPDATE emp5
SET cdgdp = NULL;

  


ALTER TABLE emp5
  RENAME COLUMN sal  TO salario;


ALTER TABLE emp5
  DROP COLUMN posto;

ALTER TABLE emp5
   DROP (nome, supervisor);







CREATE TABLE emp1
   AS (SELECT *
       FROM   emp)


INSERT INTO emp1 (empno, ename, sal, deptno)
VALUES (8888,'MANOLO''S',1500,10)



SELECT *
FROM   emp1
WHERE  ename LIKE '%''%'


INSERT INTO emp1 (empno, ename, sal, deptno)
VALUES (9999,'ARK''''S',1600,20)



Aplica lo ya conocido.



Nuevamente aplica lo ya conocido.



INSERT INTO emp1 (empno, ename, sal, DEPTNO)
VALUES(9000,'MACA%ENA',1000,20)





-- Puede usarse cualquier carácter como protector del siguiente
-- indicándolo tras ESCAPE:
SELECT *
FROM emp1
WHERE ename LIKE '%a%%' ESCAPE 'a'


SELECT *
FROM emp1
WHERE ename LIKE '%MM%M%%' ESCAPE 'M'






SELECT POWER(5,2), SYSDATE
FROM DUAL



CREATE TABLE kk22
 (cdemp NUMBER NOT NULL,
  ename VARCHAR(10))


CREATE SEQUENCE sqemp
  INCREMENT BY 1 START WITH 100
-- Se accede a los valores de la secuencia mediante:
-- sqemp.CURRVAL   Devuelve el valor actual de la secuencia.
-- sqemp.NEXTVAL   Incrementa el valor de la secuencia, y devuelve
--                 el nuevo resultado.


INSERT INTO kk22 VALUES (sqemp.NEXTVAL,'Manolo')
INSERT INTO kk22 VALUES (sqemp.NEXTVAL,'Juan')
INSERT INTO kk22 VALUES (sqemp.NEXTVAL,'Pepe')



DELETE FROM kk22
WHERE cdemp = 101;



INSERT INTO kk22 VALUES (sqemp.NEXTVAL,'Luz');






SELECt sqemp.currval
FROM DUAL

   CURRVAL
----------
       104

Normalmente no se usan ni CURRVAL ni  NEXTVAL en las consultas, y
además no pueden aparecer en SELECT que temgan algunas propiedades.





CREATE TABLE kk23
( c1 VARCHAR(10),
  c2 CHAR(5));

INSERT INTO kk23 VALUES(sqemp.NEXTVAL,'Proba');



INSERT INTO kk23 VALUES(sqemp.CURRVAL,'Duas');




SELECT sqemp.NEXTVAL FROM DUAL;
ALTER SEQUENCE sqemp INCREMENT BY 4:
SELECT sqemp.NEXTVAL FROM DUAL;
SELECT sqemp.NEXTVAL FROM DUAL;



BASES DE DATOS 2                       Ingenieria Informatica-Cuarto Curso           
Profesor: Luis A. Glez. Ares                     Curso Academico 2003-2004
--------------------------------------------------------------------------
                            (Fichero sin acentos para facilitar su lectura
                             en distintas plataformas)


EJEMPLOS DE SQL*Loader
----------------------

Estos son dos ejemplos elementales de utilizacion del SQL*Loader,
pero son suficientes para la introduccion de la gran mayoria de los datos.
Hay otras opciones y posibilidades, pero habra que consultar el manual
para su correcta utilizacion (Oracle9i Database Utilities).
En el examen entra SQL*Loader, pero solo con el grado de dificultad
expuesto en estos ejemplos.


Creamos una tabla de prueba:

SQL> CREATE TABLE p1
     ( cd     CHAR(3),
       nme    CHAR(10),
       sal    NUMBER,
       dia    DATE);

cuya descripcion es:

SQL> desc p1
 Name                            Null?    Type
 ------------------------------- -------- ----
 CD                                       CHAR(3)
 NME                                      CHAR(10)
 SAL                                      NUMBER
 DIA                                      DATE



Ejemplo 1
---------

- Los datos que queremos introducir estan en el fichero p1.dat
que tiene solo las cuatro filas que aparecen bajo los guiones:

123456789012345678901234
------------------------
101 fila 1     50 980423
102 fila 2     51 980424
103            52 980425
104 fila 4        980426


- El fichero de control que usamos es p1.ctl que es el siguiente:

load data
infile 'p1.dat'
into table p1
(cd   position(1:3)   char,
 nme  position(5:14)  char,
 sal  position(15:17) integer external,
 dia  position(19:24) date 'YYMMDD')


- Ejecutamos el SQL*Loader:

$ sqlldr  /  control=p1

- Siempre comprobaremos el fichero de log (aqui: p1.log).

- Realizamos una llamada desde el operativo a sqlplus:

$ sqlplus / @p1

- Con esto ejecutamos el fichero p1.sql que contiene:

select *
from p1;
exit

- Y obtenemos:

SQL*Plus: Release 9.2.0.4.0 - Production on Mié Ene 14 09:35:39 2004

Copyright (c) 1982, 2002, Oracle Corporation.  All rights reserved.


Conectado a:
Oracle9i Enterprise Edition Release 9.2.0.4.0 - Production
With the Partitioning, OLAP and Oracle Data Mining options
JServer Release 9.2.0.4.0 - Production


CD  NME            SAL DIA
--- ---------- ------- --------
101 fila 1          50 23/04/98
102 fila 2          51 24/04/98
103                 52 25/04/98
104 fila 4             26/04/98

4 filas seleccionadas.

Desconectado de Oracle9i Enterprise Edition Release 9.2.0.4.0 - Production
With the Partitioning, OLAP and Oracle Data Mining options
JServer Release 9.2.0.4.0 - Production


- Luego podemos comprobar los valores nulos:

SQL> select *
     from p1
     where nme is null;

CD  NME 	   SAL DIA
--- ---------- ------- ---------
103		    52 25/04/98


SQL> select *
     from p1
     where sal is null;

CD  NME 	   SAL DIA
--- ---------- ------- ---------
104 fila 4	       26/04/98



Ejemplo 2
---------
- Suponemos que la tabla p1 esta vacia, para lo cual hemos 
eliminado las filas de la carga anterior.
Los datos que deseamos introducir estan delimitados con comas.
Sobre ese fichero incluimos los comandos del SQL*Loader y 
tenemos un fichero de control que contiene los datos.

- El fichero de control es p11.ctl:

load data
infile *
into table p1
fields terminated by ',' optionally enclosed by '"'
 (cd, nme, sal, dia date 'YYMMDD')
begindata
200, filauno, 3,980427
201,"fila's", 4,980428


- Ejecutamos el SQL*Loader:

$ sqlldr / control=p11

SQL*Loader: Release 9.2.0.4.0 - Production on Mié Ene 14 09:39:22 2004

Copyright (c) 1982, 2002, Oracle Corporation.  All rights reserved.

SQL*Loader-601: Para la opción INSERT, la tabla debe estar vacía. Error en la tabla P1


- Nos da un error debido a que la tabla no esta vacia. Por ahora
entramos en sqlplus y eliminamos todas las filas:

SQL> delete from p1;


- Salimos y ejecutamos de nuevo el SQL*Loader con el fichero de control p11:

$ sqlldr / control=p11

SQL*Loader: Release 9.2.0.4.0 - Production on Mié Ene 14 09:41:17 2004

Copyright (c) 1982, 2002, Oracle Corporation.  All rights reserved.

Punto de validación alcanzado - recuento de registros lógicos 2


- Comprobamos el contenido de la tabla:

$ sqlplus / @p1

SQL*Plus: Release 9.2.0.4.0 - Production on Mié Ene 14 09:42:12 2004

Copyright (c) 1982, 2002, Oracle Corporation.  All rights reserved.


Conectado a:
Oracle9i Enterprise Edition Release 9.2.0.4.0 - Production
With the Partitioning, OLAP and Oracle Data Mining options
JServer Release 9.2.0.4.0 - Production


CD  NME            SAL DIA
--- ---------- ------- --------
200 filauno          3 27/04/98
201 fila's           4 28/04/98

2 filas seleccionadas.

Desconectado de Oracle9i Enterprise Edition Release 9.2.0.4.0 - Production
With the Partitioning, OLAP and Oracle Data Mining options
JServer Release 9.2.0.4.0 - Production


- Ahora decidimos introducir mas filas en la tabla p1. Para ello usamos
el fichero de control p12.ctl:

load data
infile *
append
into table p1
fields terminated by ','
 (cd, nme, sal, dia date 'YYMMDD')
begindata
400, masfilas, 3,980427
401, masfilas, 4,980428


- Ejecutamos el SQL*Loader:

$ sqlldr / control=p12

SQL*Loader: Release 9.2.0.4.0 - Production on Mié Ene 14 09:43:43 2004

Copyright (c) 1982, 2002, Oracle Corporation.  All rights reserved.

Punto de validación alcanzado - recuento de registros lógicos 2


- Comprobamos el contenido de la tabla:

$ sqlplus / @p1

SQL*Plus: Release 9.2.0.4.0 - Production on Mié Ene 14 09:44:19 2004

Copyright (c) 1982, 2002, Oracle Corporation.  All rights reserved.


Conectado a:
Oracle9i Enterprise Edition Release 9.2.0.4.0 - Production
With the Partitioning, OLAP and Oracle Data Mining options
JServer Release 9.2.0.4.0 - Production


CD  NME            SAL DIA
--- ---------- ------- --------
200 filauno          3 27/04/98
201 fila's           4 28/04/98
400  masfilas        3 27/04/98
401  masfilas        4 28/04/98

4 filas seleccionadas.

Desconectado de Oracle9i Enterprise Edition Release 9.2.0.4.0 - Production
With the Partitioning, OLAP and Oracle Data Mining options
JServer Release 9.2.0.4.0 - Production


Es la intersección de ambas.



SELECT empno, ename  
FROM   emp1
MINUS 
SELECT empno, ename  
FROM   emp


SELECT empno, ename  
FROM   ops$lgares.emp1
MINUS 
SELECT empno, ename  
FROM   emp



CREATE TABLE w1 (c CHAR(1));
INSERT INTO  w1  VALUES ('a');
...

CREATE TABLE w2 (c CHAR(1));
INSERT INTO  w2  VALUES ('a');
...







En Oracle EXCEPT era MINUS.



SELECT c  FROM w1  INTERSECT  SELECT c  FROM w2









pro:    Proyecto
projno  Número de proyecto (identificador)
pname   Nombre del proyecto
loc     Ciudad en la que se realiza el proyecto
deptno  Departamento que dirige o que es responsable del proyecto

emppro: Empleado y proyectos en los que trabaja
empno   Número de empleado 
projno  Número de proyecto
hours   Horas de dedicación 
  (empno, projno) identificador

Esquema relacional:

                                               dept(deptno, dname, loc)
                                                    ^    ^
                                                    |    |
emp(empno, ename, job, mgr, hiredate, sal, comm, deptno) |
       ^^                                                |
       ||___________|                                    | 
       |                                                 |
       |                      pro(projno, pname, loc, deptno)     
       |                             ^
emppro(empno, projno, hours)         |
                 |___________________|






SELECT *
FROM   dept
WHERE  (deptno, loc) IN (SELECT deptno, loc
                         FROM   pro);







SELECT   deptno, dname, projno, pname
FROM     dept NATURAL JOIN pro 


Es el ejercicio número 6, ahora con otra solución:

SELECT empno, ename, sal, deptno
FROM   emp a
WHERE  (deptno,sal) IN (SELECT deptno,MIN(sal)
                        FROM   EMP
                        GROUP BY deptno)



SELECT *
FROM emp3;

-- Estado de emp3 (se habían añadido las filas de GARCIA y de GOMEZ):

EMPNO ENAME      JOB         MGR HIREDATE     SAL    COMM DEPTNO
----- ---------- --------- ----- -------- ------- ------- ------
 7369 SMITH      CLERK      7902 17/12/80     800             20
 7499 ALLEN      SALESMAN   7698 20/02/81   1,600     300     30
 7521 WARD       SALESMAN   7698 22/02/81   1,250     500     30
 7566 JONES      MANAGER    7839 02/04/81   2,975             20
 7654 MARTIN     SALESMAN   7698 28/09/81   1,250   1,400     30
 7698 BLAKE      MANAGER    7839 01/05/81   2,850             30
 7782 CLARK      MANAGER    7839 09/06/81   2,450             10
 7788 SCOTT      ANALYST    7566 09/12/82   3,000             20
 7839 KING       PRESIDENT       17/11/81   5,000             10
 7844 TURNER     SALESMAN   7698 08/09/81   1,500       0     30
 7876 ADAMS      CLERK      7788 12/01/83   1,100             20
 7900 JAMES      CLERK      7698 03/12/81     950             30
 7902 FORD       ANALYST    7566 03/12/81   3,000             20
 7934 MILLER     CLERK      7782 23/01/82   1,300             10
 7777 GARCIA     ANALYST    7566 12/01/81   1,600             20
 8888 GOMEZ      CLERK      7566 12/01/81     950             20

16 filas seleccionadas.

SELECT empno, ename, sal, comm, deptno
FROM   emp3
WHERE   sal                 IN  (SELECT sal
                                 FROM   emp3 a, dept b
                                 WHERE  a.deptno = b.deptno
                                 AND    LOWER(b.loc) = 'chicago')
OR     NVL(comm, -1)       IN  (SELECT NVL(comm, -1)
                                 FROM   emp3 a, dept b
                                 WHERE  a.deptno = b.deptno
                                 AND    loc = 'CHICAGO')
ORDER BY deptno, empno
















SELECT   empno, ename, sal, deptno, min_sal min, sal - min_sal difer
FROM     emp a, (SELECT MIN(sal) min_sal
                 FROM   emp)
WHERE    sal >  min_sal
ORDER BY sal









EMPNO ENAME          SAL     PROJNO      HOURS
----- ---------- ------- ---------- ----------
 7499 ALLEN        1,600       1004         15
 7499 ALLEN        1,600       1005         12
 ...




Busca dos expresiones diferentes pero equivalentes.




EMPNO ENAME          SAL     PROJNO      HOURS
----- ---------- ------- ---------- ----------
 7369 SMITH          800
 7499 ALLEN        1,600       1004         15
 ...







Deben salir 10 filas.






EMPNO ENAME          SAL DEPTNO DNAME          DEPTNO DNAME
----- ---------- ------- ------ -------------- ------ --------------
 7499 ALLEN        1,600     30 SALES              30 SALES
 7521 WARD         1,250     30 SALES              30 SALES
 ...











Si has obtenido una solución, espero que hayas sido elegante y que no tengas
que revisarla para eliminar los FULL innecesarios.



CREATE TABLE emp4
AS SELECT * FROM emp


















Salario medio modificado   COUNT(*) DEPTNO
------------------------ ---------- ------
                    3150          3     10
                    2595          5     20
              2141,66667          6     30

3 filas seleccionadas.

	
 
CREATE TABLE kk1
   (cd NUMBER, nmb CHAR(5), tmp DATE)

Oracle almacena los datos referentes a fechas y tiempo en 
un tipo de dato DATE, que permite almacenar fechas, tiempo y
ambos a la vez.
Debe usarse la función de Oracle TO_DATE para convertir una
expresión carácter a una fecha, y en ella usar las máscaras 
de formateo adecuadas a la expresión:

INSERT INTO kk1 VALUES (10,'nome',TO_DATE('03:45','HH24:MI'))

Algunas otras máscaras son:

D     Día de la semana (1-7)
DD    Día del mes (1-31)
DDD   Día del año (1-366)
DAY   Nombre del día
HH    Hora del día (1-12)
HH12  Idem
HH24  Hora del día (1-24)
MI    Minuto (0-59)
MM    Mes (01-12; JAN = 01)  
MON   Nombre del mes abreviado
MONTH Nombre del mes
SS    Segundo (0-59)
YYYY  Año
YYY   Ultimos tres dígitos del año
YY    Ultimos dos dígitos del año
Y     Ultimo dígito del año



     SELECT * FROM kk1;

        CD NMB   TMP
---------- ----- --------
        10 nome  01/03/04

Se trata realmente de un error?
El ejercicio siguiente nos lo aclara.



SELECT cd, nmb, TO_CHAR(tmp,'HH24:MI')
FROM   kk1

        CD NMB   TO_CH
---------- ----- -----
        10 nome  03:45

De la misma forma que usamos antes TO_DATE, ahora debemos usar TO_CHAR



INSERT INTO kk1 
VALUES (11,'n11',TO_DATE('19:12','HH24:MI'));

INSERT INTO kk1 
VALUES (12,'n12',TO_DATE('00:02','HH24:MI'));


SELECT cd, nmb, TO_CHAR(tmp,'HH24:MI')
FROM   kk1
ORDER BY 3

        CD NMB   TO_CH
---------- ----- -----
        12 n12   00:02
        10 nome  03:45
        11 n11   19:12



ALTER TABLE kk1 ADD dta DATE


De nuevo hay que usar la máscara apropiada:

INSERT INTO kk1 
VALUES (13,'n13',TO_DATE('09:09','HH24:MI'),TO_DATE('14-04-2002','DD-MM-YYYY'))

INSERT INTO kk1 
VALUES (14,'n14',TO_DATE('14:09','HH24:MI'),TO_DATE('18-02-2002','DD-MM-YYYY'))



SELECT cd, nmb, TO_CHAR(tmp,'HH24:MI'), TO_CHAR(dta,'DD-MM-YYYY')
FROM   kk1

        CD NMB   TO_CH TO_CHAR(DT
---------- ----- ----- ----------
        10 nome  03:45
        11 n11   19:12
        12 n12   00:02
        13 n13   09:09 14-04-2002
        14 n14   14:09 18-02-2002

Si hubiéramos forzado la salida de una fecha en la columna tmp y de
una hora en dta, obtendríamos:

SELECT cd, nmb, TO_CHAR(tmp,'DD-MM-YYYY HH24:MI'), TO_CHAR(dta,'DD-MM-YYYY HH24:MI')
FROM   kk1

        CD NMB   TO_CHAR(TMP,'DD- TO_CHAR(DTA,'DD-
	---------- ----- ---------------- ----------------
        10 nome  01-03-2004 03:45
        11 n11   01-03-2004 19:12
        12 n12   01-03-2004 00:02
        13 n13   01-03-2004 09:09 14-04-2002 00:00
        14 n14   01-03-2004 14:09 18-02-2002 00:00


SELECt cd, nmb, TO_CHAR(tmp,'HH24:MI'), TO_CHAR(dta,'DD-MM-YYYY')
FROM   kk1
ORDER BY 4

        CD NMB   TO_CH TO_CHAR(DT
---------- ----- ----- ----------
        13 n13   09:09 14-04-2002
        14 n14   14:09 18-02-2002
        10 nome  03:45
        11 n11   19:12
        12 n12   00:02        

Observa que el resultado no es lo deseado !




SELECt   cd, nmb, TO_CHAR(tmp,'HH24:MI'), TO_CHAR(dta,'DD-MM-YYYY')
FROM     kk1
ORDER BY dta


        CD NMB   TO_CH TO_CHAR(DT
---------- ----- ----- ----------
        14 n14   14:09 18-02-2002
        13 n13   09:09 14-04-2002
        10 nome  03:45
        11 n11   19:12
        12 n12   00:02

5 filas seleccionadas.









RESPUESTA 1

RESPUESTA 2

RESPUESTA 3

RESPUESTA 4

RESPUESTA 5

RESPUESTA 6

RESPUESTA 7

RESPUESTA 8

RESPUESTA 9

RESPUESTA 10

RESPUESTA 11

RESPUESTA 12

RESPUESTA 13

RESPUESTA 14

RESPUESTA 15

RESPUESTA 16

RESPUESTA 17

RESPUESTA 18

RESPUESTA 19

RESPUESTA 20

RESPUESTA 21

RESPUESTA 22

RESPUESTA 23

RESPUESTA 24

RESPUESTA 25

RESPUESTA 26

RESPUESTA 27

RESPUESTA 28

RESPUESTA 29

RESPUESTA 30

RESPUESTA 31

RESPUESTA 32

RESPUESTA 33

RESPUESTA 34

RESPUESTA 35

RESPUESTA 36

RESPUESTA 37

RESPUESTA 38

RESPUESTA 39

RESPUESTA 40

RESPUESTA 41

RESPUESTA 42

RESPUESTA 43

RESPUESTA 44

RESPUESTA 45

RESPUESTA 46

RESPUESTA 47

RESPUESTA 48

RESPUESTA 49

RESPUESTA 50

RESPUESTA 51

RESPUESTA 52

RESPUESTA 53

RESPUESTA 54

RESPUESTA 55

RESPUESTA 56

RESPUESTA 57

RESPUESTA 58

RESPUESTA 59

RESPUESTA 60

RESPUESTA 61

RESPUESTA 62

RESPUESTA 63

RESPUESTA 64

RESPUESTA 65

RESPUESTA 66

RESPUESTA 67

RESPUESTA 68

RESPUESTA 69

RESPUESTA 70

RESPUESTA 71

RESPUESTA 72

RESPUESTA 73

RESPUESTA 74

RESPUESTA 75

RESPUESTA 76

RESPUESTA 77

RESPUESTA 78

RESPUESTA 79

RESPUESTA 80

RESPUESTA 81

RESPUESTA 82

RESPUESTA 83

RESPUESTA 84

RESPUESTA 85

RESPUESTA 86

RESPUESTA 87

RESPUESTA 88

RESPUESTA 89

RESPUESTA 90

RESPUESTA 91

RESPUESTA 92

RESPUESTA 93

RESPUESTA 94

RESPUESTA 95

RESPUESTA 96

RESPUESTA 97

RESPUESTA 98

RESPUESTA 99

RESPUESTA 100

RESPUESTA 101

RESPUESTA 102

RESPUESTA 103

RESPUESTA 104

RESPUESTA 105

RESPUESTA 106

RESPUESTA 107

RESPUESTA 108

RESPUESTA 109

RESPUESTA 110

RESPUESTA 111

RESPUESTA 112

RESPUESTA 113

RESPUESTA 114

RESPUESTA 115

RESPUESTA 116

RESPUESTA 117

RESPUESTA 118

RESPUESTA 119

RESPUESTA 120

RESPUESTA 121

RESPUESTA 122

RESPUESTA 123

RESPUESTA 124

RESPUESTA 125

RESPUESTA 126

RESPUESTA 127

RESPUESTA 128

RESPUESTA 129

RESPUESTA 130

RESPUESTA 131

RESPUESTA 132

SELECT   cd, nmb, TO_CHAR(tmp,'HH24:MI') Hora,
         TO_CHAR(dta,'DD "of" Month YYYY') "Ano"
FROM     kk1
ORDER BY dta, tmp



Algunas funciones para el manejo de fechas:
ADD_MONTHS (d,n)    Añade m meses a la fecha d
LAST_DAY (d)        Fecha del último día del mes de la fecha d
MONTHS_BETWEEN (d1, d2)  Meses entre d1 y d2
NETX_DAY (d, day)   La fecha del primer day después de la fecha d
SYSDATE             Fecha de hoy




SQL> desc temp
 Nombre                                    Â¿Nulo?   Tipo
 ----------------------------------------- -------- ----------------------------
 CD_EMP                                    NOT NULL CHAR(2)
 NSS                                                CHAR(5)
 FCTO                                               DATE
 SEX                                                CHAR(1)

SQL> desc thst_emp
 Nombre                                    Â¿Nulo?   Tipo
 ----------------------------------------- -------- ----------------------------
 CD_EMP                                    NOT NULL CHAR(2)
 TVI                                       NOT NULL DATE
 TVF                                                DATE
 TTI                                                DATE
 TTF                                                DATE
 NMB                                                CHAR(10)
 SAL                                                NUMBER
 CD_DPTO                                            CHAR(2)
 CD_CTG                                             CHAR(2)


En ellas se revisa la primera alternativa de tratamiento temporal
comentada en las clases de aula.

Vamos a suponer que la clave primaria de TEMP es CD_EMP, y la de
THST_EMP es (CD_EMP,TVI); por ahora las creamos como no nulas.

La columna TVF sólo puede tener una fila con valor nulo para cada CD_EMP,
ya que representa el tiempo de validez final
(no están  incluidas en Oracle estas restricciones, 
pero sí debe tenerse en cuenta).

Pueden introducirse valores futuros, lo que quiere decir que puede 
saberse que en una fecha conocida pero futura un empleado pasará a 
otra situación, y almacenar el dato en la BD.

Estas tablas pueden referenciarlas directamente por el nombre.


CD TVI      TVF      TTI      TTF      NMB            SAL CD CD
-- -------- -------- -------- -------- ---------- ------- -- --
a  15/01/02 19/01/02 24/01/02          Aaa          4,000 30 C
a  20/01/02          25/01/02          Aaa          5,000 30 C
a  01/01/02 04/01/02 21/01/02          Aaa          1,000 10 D
a  05/01/02 09/01/02 22/01/02          Aaa          2,000 10 D
a  10/01/02 14/01/02 23/01/02          Aaa          3,000 20 C
b  16/01/02          25/01/02          Bbb          2,000 20 B
b  10/01/02 15/01/02 25/01/02          Bbb          1,000 20 B

Para facilitar la escritura de las sentencias, los tipos de dato DATE 
siguen el formato estándar, con lo que pueden realizarse consultas sin 
usar TO_CHAR, ni en INSERT ni en SELECT.

INSERT INTO thst_emp
VALUES ('b','16/01/2002',NULL,'25/01/2002',NULL,'Bbb',2000,'20','B')


SELECT *
FROM thst_emp


En este y en los siguientes ejercicios relacionados, y sólo por 
motivos de facilitar la visualización usaremos:
SELECT  b.*  
FROM    temp a, thst_emp b 
WHERE   ...
en vez de SELECT * ...

El resultado debe ser:
CD TVI      TVF      TTI      TTF      NMB            SAL CD CD
-- -------- -------- -------- -------- ---------- ------- -- --
a  01/01/02 04/01/02 21/01/02          Aaa          1,000 10 D
b  10/01/02 15/01/02 25/01/02          Bbb          1,000 20 B

2 filas seleccionadas.



Tal vez hayas probado lo siguiente:

SELECT b.*
FROM   temp a JOIN thst_emp b
  ON   a.cd_emp = b.cd_emp
WHERE  '15/01/02' BETWEEN tvi AND tvf
ORDER BY 1

pero deberías de entender que es incorrecto y el motivo.
Resuelve la consulta.



Revisa lo comentado sobre el catálogo y determina en qué vista
estarán las tablas propias.
Comprueba siempre la descripción de cada objeto del catálogo.



Si no se ha creado por el usuario y no se indica un
propietario, entonces qué puede ser ...  



Comprueba entre los objetos del catálogo de qué puede tratarse
(considera si lo has creado tú o no, y de ahí se deduce en qué
vista puede estar, según la naturaleza que tenga).



EL comienzo es similar al anterior.



Se accede mediante la vista DICTIONARY.
Para obtener el número de algo, usábamos una función de conjunto.
El número de objetos resultante depende de los privilegios del
usuario que realiza la consulta.



Hay que buscar en la vista adecuada un sinónimo que referencie
a 'DICTIONARY'



Revisa las notas de clase o usa otros medios para determinar la
vista en la que se encuentra la información.



SELECT USER
FROM   DUAL


Consulta sobre la vista del ejercicio previo, con una condición
sobre el nombre de usuario.

SELECT *
FROM   ALL_USERS
WHERE  USERNAME LIKE '___$____CD%'



Ya lo hicimos muchas veces: una simple
sentencia es suficiente.



Un sinónimo es un objeto del esquema, así que seguro que
hay una sentencia DDL para su creación.



DESC mitabla
SELECT *
FROM   mitabla


DROP TABLE dept5









Una consulta sobre el mismo objeto ahora obtiene datos muy
diferentes.





DESC   USER_CATALOG
SELECT *
FROM   USER_CATALOG





Las que comienzan por DBA realmente existen, a pesar del mensaje
de error, pero hay que ser DBA para acceder a ellas.
Describe por tanto las equivalentes pero a las que tengas acceso:
ALL_...
Mejor no consultes sus datos, porque en algunas puede haber mucha
información.


Ahora con las USER_...



SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES


SELECT   TABLE_NAME, COLUMN_NAME
FROM     USER_TAB_COLUMNS 
ORDER BY 1



SELECT   *
FROM     TAB
ORDER BY 2,1



El fichero debe poder ejecutarse desde el sistema operativo 
-como argumento de algo-, obtener lo pedido, y devolvernos 
al operativo.



La estructura elemental es la siguiente. Cópiala y completa el
CREATE TABLE. Nombra las restricciones.

empno      NUMBER(4)
ename      CHAR(10) NOT NULL
mgr        NUMBER(4)
comm       NUMBER(7,2)
deptno     NUMBER(5) NOT NULL

    

deptno     NUMBER(5)
dname      VARCHAR2(15)
loc        VARCHAR(15)



Qué tabla o tablas debemos consultar?. Descríbelas y asegúrate de entender
sus principales atributos.
SQL> desc user_constraints
 Nombre                                    ¿Nulo?   Tipo
 ----------------------------------------- -------- ------------------
 OWNER                                     NOT NULL VARCHAR2(30)
 CONSTRAINT_NAME                           NOT NULL VARCHAR2(30)
 CONSTRAINT_TYPE                                    VARCHAR2(1)
 TABLE_NAME                                NOT NULL VARCHAR2(30)
 SEARCH_CONDITION                                   LONG
 R_OWNER                                            VARCHAR2(30)
 R_CONSTRAINT_NAME                                  VARCHAR2(30)
 DELETE_RULE                                        VARCHAR2(9)
 STATUS                                             VARCHAR2(8)
 DEFERRABLE                                         VARCHAR2(14)
 DEFERRED                                           VARCHAR2(9)
 VALIDATED                                          VARCHAR2(13)
 GENERATED                                          VARCHAR2(14)
 BAD                                                VARCHAR2(3)
 RELY                                               VARCHAR2(4)
 LAST_CHANGE                                        DATE
 INDEX_OWNER                                        VARCHAR2(30)
 INDEX_NAME                                         VARCHAR2(30)
 INVALID                                            VARCHAR2(7)
 VIEW_RELATED                                       VARCHAR2(14)

SQL> desc user_cons_columns
 Nombre                                    ¿Nulo?   Tipo
 ----------------------------------------- -------- ------------------
 OWNER                                     NOT NULL VARCHAR2(30)
 CONSTRAINT_NAME                           NOT NULL VARCHAR2(30)
 TABLE_NAME                                NOT NULL VARCHAR2(30)
 COLUMN_NAME                                        VARCHAR2(4000)
 POSITION                                           NUMBER

   

La carga la hacíamos mediante una sentencia muy sencilla, un simple INSERT.




50,VENTAS,BOSTON
50,DISTRIBUCION,BOSTON
60,NULL,SAN DIEGO
NULL,ADMINISTRACION,LOS ANGELES
70,ADMINISTRACION,LOS ANGELES
80,NULL,LOS ANGELES



ALTER TABLE ...






Puede hacerse?







ALTER TABLE emp1
ADD CONSTRAINT ck_emp1_sal CHECK (sal > 0);


Comprobad si hay información en USER_CONSTRAINTS
referente a esa restricción, y las columnas que indican si es de
comprobación aplazada o no.



La restricción debe declararse en cualquier caso.
Qué hay que hacer entonces?



Comprobad si hay información en USER_CONSTRAINTS
referente a esa restricción, y las columnas que indican si es de
comprobación aplazada o no.



UPDATE dept1
SET ctd = 5000;





 
 INSERT INTO emp1 VALUES (7000, 'LUCIA', 7500, NULL, 20, 1400)

 Pero está claro que no nos deja incluir la fila de MARIA:
 INSERT INTO emp1 VALUES (8000, 'MARIA', 8500, NULL, 90, 1400)




 INSERT INTO dept1 VALUES (90, 'OTRO', 'NY', 4000)

 INSERT INTO emp1 VALUES (8000, 'MARIA', 8500, NULL, 90, 1400)



 DELETE FROM dept1 WHERE deptno = 90

SQL> select * from user_constraints where constraint_name = 'CF_EMP1_DEPTNO';

OWNER                          CONSTRAINT_NAME                C
------------------------------ ------------------------------ -
TABLE_NAME
------------------------------
SEARCH_CONDITION
--------------------------------------------------------------------------------
R_OWNER                        R_CONSTRAINT_NAME              DELETE_RU STATUS
------------------------------ ------------------------------ --------- --------
DEFERRABLE     DEFERRED  VALIDATED     GENERATED      BAD RELY LAST_CHA
-------------- --------- ------------- -------------- --- ---- --------
INDEX_OWNER                    INDEX_NAME                     INVALID
------------------------------ ------------------------------ -------
VIEW_RELATED
--------------
OPS$LGARES                     CF_EMP1_DEPTNO                 R
EMP1

OPS$LGARES                     CP_DEPT1                       SET NULL  ENABLED
NOT DEFERRABLE IMMEDIATE VALIDATED     USER NAME               06/04/04


 ALTER TABLE emp1
 DROP CONSTRAINTS NN_EMP1_DEPTNO;

 DELETE FROM dept1 WHERE deptno = 90;







 INSERT INTO dept1 VALUES (90, 'OTRO', 'NY', 4000);

 UPDATE emp1
 SET deptno = 90
 WHERE empno = 8000;

 DELETE FROM dept1 WHERE deptno = 90


Sobre qué columna tendremos que actuar?



Comprobamos que no es posible.








En Oracle 9i la eliminación de la columna mgr se haría con: 

ALTER TABLE emp1
   DROP COLUMN mgr;




Qué sentencia se usaba para esto?
        ... IMMEDIATE;



Por ejemplo:
INSERT INTO dept1 VALUES (88,'NOVO',null,NULL)        Se puede?



RESPUESTA 133

RESPUESTA 134

RESPUESTA 135

RESPUESTA 136

RESPUESTA 137

RESPUESTA 138

RESPUESTA 139

RESPUESTA 140

RESPUESTA 141

RESPUESTA 142

RESPUESTA 143

RESPUESTA 144

RESPUESTA 145

RESPUESTA 146

RESPUESTA 147

RESPUESTA 148

RESPUESTA 149

RESPUESTA 150

RESPUESTA 151

RESPUESTA 152

RESPUESTA 153

RESPUESTA 154

RESPUESTA 155

RESPUESTA 156

RESPUESTA 157

RESPUESTA 158

RESPUESTA 159

RESPUESTA 160

RESPUESTA 161

RESPUESTA 162

RESPUESTA 163

RESPUESTA 164

RESPUESTA 165

RESPUESTA 166

RESPUESTA 167

RESPUESTA 168

RESPUESTA 169

RESPUESTA 170

RESPUESTA 171

RESPUESTA 172

RESPUESTA 173

RESPUESTA 174

RESPUESTA 175

RESPUESTA 176

RESPUESTA 177

RESPUESTA 178

RESPUESTA 179

RESPUESTA 180

RESPUESTA 181

RESPUESTA 182

RESPUESTA 183

RESPUESTA 184

RESPUESTA 185

RESPUESTA 186

RESPUESTA 187

RESPUESTA 188
